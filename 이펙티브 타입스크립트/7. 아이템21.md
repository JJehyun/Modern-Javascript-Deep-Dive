# 아이템 21 `타입 넓히기` 🎯💡🔥📌

## 타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에, 변수는 '가능한' 값들의 집합을 가진다.

- `넓히기` : 타입스크립트에서의 과정으로 `지정된 단일 값`을 가지고 `할당 가능한 값들의 집합`을 `유추` 해야한다는 뜻

- 상수를 사용해서 변수를 초기화할 때 타입을 `명시하지 않으면` 타입 체커는 타입을 결정 해야 한다.
  - 즉, 지정된 `단일 값`을 가지고 할당 가능한 집합을 유추해야하는데 이를 `타입 넓히기`라고 한다.

<br />

> 위 예시

```js
interface Vector3 {
  x: number
  y: number
  z: number
}

const getComponent = (vector: Vector3, axis: 'x' | 'y' | 'z') => {
  return vector[axis]
}

let x = 'x' // 타입은 string
let vec = {x:10, y:20, z: 30};

getComponent(vec, x) // 'string' 형식의 인수는 '"x" | "y" | "z"' 형식의 매개 변수에 할당될 수 없습니다.
```

> getComponent함수는 두 번째 매개변수에 `"x" | "y" | "z"` 타입을 기대하지만, x의 타입은 할당 시점에 `string`으로 추론된다.

<br />

> 타입 넓히기가 진행될 때, 주어진 값으로 추론 가능한 타입이 여러 개이기 때문에 과정이 모호하다

<br />
<br />

## 넓히기의 과정을 제어하는 방법

- `const`의 사용
  - 재할당이 `불가능` 하기 때문에 타입스크립트는 좁은 타입으로 추론이 가능하다.
  - 📌 객체의 경우엔 각 요소를 let으로 할당된 거 처럼 다룬다.

<br />

> 예시

```js
const x = "x"; // 타입은 'x'
```

<br />
<br />

## 타입 추론의 강도를 직점 제어하여 타입스크립트의 기본 동작을 제어하는 방법

1. 명지적 타입 구문 제공

```js
//타입은 {x : 1|3|5; }
const v: { x: 1 | 3 | 5 } = { x: 1 };
```

2. 타입 체커에 추가적인 문맥을 제공 (함수의 매개변수로 값을 전달)

3. `const 단언문 제공` (값 뒤에 as `const`를 작성하면 타입스크립트는` 최대한 좁은 타입`을 `추론`한다.)

```js
const v1 = {
  x: 1,
  y: 2,
}; // type : {x: number; y: number;}
const v2 = {
  x: 1 as const,
  y: 2,
}; // type : {x: 1; y: number;}
const v3 = {
  x: 1,
  y: 2,
} as const; // type : {readonly x: 1; readonly y: 2;}
```
